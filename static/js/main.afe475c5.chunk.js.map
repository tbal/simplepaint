{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["HOOK_PATH","Path2D","usePersistentCanvas","init","React","useState","JSON","parse","localStorage","getItem","value","setValue","useEffect","setItem","stringify","usePersistentState","locations","setLocations","canvasRef","useRef","ctx","current","getContext","clearRect","window","innerWidth","innerHeight","forEach","location","fillStyle","shadowColor","shadowBlur","save","scale","translate","x","y","fill","restore","draw","App","console","log","className","onClick","slice","source","filename","link","document","createElement","setAttribute","style","display","body","appendChild","click","removeChild","download","toDataURL","ref","width","height","e","newLocation","clientX","clientY","Boolean","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"4NAQMA,G,MAAY,IAAIC,OADpB,48BA2BF,SAASC,IAAuB,IAAD,EAZ/B,SAA4BC,GAAO,IAAD,EACNC,IAAMC,SAC9BC,KAAKC,MAAMC,aAAaC,QAAQ,cAAgBN,GAFlB,mBACzBO,EADyB,KAClBC,EADkB,KAShC,OAJAP,IAAMQ,WAAU,WACdJ,aAAaK,QAAQ,WAAYP,KAAKQ,UAAUJ,OAG3C,CAACA,EAAOC,GAImBI,CAAmB,IADxB,mBACtBC,EADsB,KACXC,EADW,KAEvBC,EAAYd,IAAMe,OAAO,MAU/B,OARAf,IAAMQ,WAAU,WACd,IACMQ,EADSF,EAAUG,QACNC,WAAW,MAE9BF,EAAIG,UAAU,EAAG,EAAGC,OAAOC,WAAYD,OAAOE,aAC9CV,EAAUW,SAAQ,SAAAC,GAAQ,OAhC9B,SAAcR,EAAKQ,GACjBR,EAAIS,UAAY,cAChBT,EAAIU,YAAc,aAClBV,EAAIW,WAAa,GACjBX,EAAIY,OACJZ,EAAIa,MAPQ,OAQZb,EAAIc,UAAUN,EAASO,EARX,GACC,GAO8BP,EAASQ,EARxC,GACC,IAQbhB,EAAIiB,KAAKrC,GACToB,EAAIkB,UAwB4BC,CAAKnB,EAAKQ,SAGnC,CAACZ,EAAWC,EAAcC,GA0DpBsB,MAzCf,WAAgB,IAAD,EACgCtC,IADhC,mBACNc,EADM,KACKC,EADL,KACmBC,EADnB,KAwBb,OAFAuB,QAAQC,IAAIlC,cAGV,oCACE,yBAAKmC,UAAU,YACb,4BAAQC,QAnBd,WACE3B,EAAa,MAkBT,SACA,4BAAQ2B,QAhBd,WACE3B,EAAaD,EAAU6B,MAAM,GAAI,MAe7B,QACA,4BAAQD,QAbd,YA9BF,SAAkBE,GAAiC,IAAzBC,EAAwB,uDAAb,YAC7BC,EAAOC,SAASC,cAAc,KAEpCF,EAAKG,aAAa,OAAQL,GAC1BE,EAAKG,aAAa,WAAYJ,GAE9BC,EAAKI,MAAMC,QAAU,OAErBJ,SAASK,KAAKC,YAAYP,GAC1BA,EAAKQ,QACLP,SAASK,KAAKG,YAAYT,GAuBxBU,CAFexC,EAAUG,QAETsC,eAUZ,eAEF,4BACEC,IAAK1C,EACL2C,MAAOrC,OAAOC,WACdqC,OAAQtC,OAAOE,YACfkB,QAhCN,SAA2BmB,GACzB,IAAMC,EAAc,CAAE7B,EAAG4B,EAAEE,QAAS7B,EAAG2B,EAAEG,SACzCjD,EAAa,GAAD,mBAAKD,GAAL,CAAgBgD,UCxDZG,QACW,cAA7B3C,OAAOI,SAASwC,UAEe,UAA7B5C,OAAOI,SAASwC,UAEhB5C,OAAOI,SAASwC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFvB,SAASwB,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLxC,QAAQwC,MAAMA,EAAMC,a","file":"static/js/main.afe475c5.chunk.js","sourcesContent":["// https://blog.koenvangilst.nl/react-hooks-with-canvas/\n\nimport React from 'react';\n\nimport './App.css'\n\nconst HOOK_SVG =\n  'm129.03125 63.3125c0-34.914062-28.941406-63.3125-64.519531-63.3125-35.574219 0-64.511719 28.398438-64.511719 63.3125 0 29.488281 20.671875 54.246094 48.511719 61.261719v162.898437c0 53.222656 44.222656 96.527344 98.585937 96.527344h10.316406c54.363282 0 98.585938-43.304688 98.585938-96.527344v-95.640625c0-7.070312-4.640625-13.304687-11.414062-15.328125-6.769532-2.015625-14.082032.625-17.960938 6.535156l-42.328125 64.425782c-4.847656 7.390625-2.800781 17.3125 4.582031 22.167968 7.386719 4.832032 17.304688 2.792969 22.160156-4.585937l12.960938-19.71875v42.144531c0 35.582032-29.863281 64.527344-66.585938 64.527344h-10.316406c-36.714844 0-66.585937-28.945312-66.585937-64.527344v-162.898437c27.847656-7.015625 48.519531-31.773438 48.519531-61.261719zm-97.03125 0c0-17.265625 14.585938-31.3125 32.511719-31.3125 17.929687 0 32.511719 14.046875 32.511719 31.3125 0 17.261719-14.582032 31.3125-32.511719 31.3125-17.925781 0-32.511719-14.050781-32.511719-31.3125zm0 0'\nconst HOOK_PATH = new Path2D(HOOK_SVG)\nconst SCALE = 0.3\nconst OFFSET = 80\nfunction draw(ctx, location) {\n  ctx.fillStyle = 'deepskyblue'\n  ctx.shadowColor = 'dodgerblue'\n  ctx.shadowBlur = 20\n  ctx.save()\n  ctx.scale(SCALE, SCALE)\n  ctx.translate(location.x / SCALE - OFFSET, location.y / SCALE - OFFSET)\n  ctx.fill(HOOK_PATH)\n  ctx.restore()\n}\n\nfunction usePersistentState(init) {\n  const [value, setValue] = React.useState(\n    JSON.parse(localStorage.getItem('draw-app')) || init\n  )\n\n  React.useEffect(() => {\n    localStorage.setItem('draw-app', JSON.stringify(value))\n  })\n\n  return [value, setValue]\n}\n\nfunction usePersistentCanvas() {\n  const [locations, setLocations] = usePersistentState([])\n  const canvasRef = React.useRef(null)\n\n  React.useEffect(() => {\n    const canvas = canvasRef.current\n    const ctx = canvas.getContext('2d')\n\n    ctx.clearRect(0, 0, window.innerWidth, window.innerHeight)\n    locations.forEach(location => draw(ctx, location))\n  })\n\n  return [locations, setLocations, canvasRef]\n}\n\nfunction download(source, filename = \"image.png\") {\n  const link = document.createElement(\"a\")\n\n  link.setAttribute(\"href\", source)\n  link.setAttribute(\"download\", filename)\n\n  link.style.display = \"none\"\n\n  document.body.appendChild(link)\n  link.click()\n  document.body.removeChild(link)\n}\n\n\nfunction App() {\n  const [locations, setLocations, canvasRef] = usePersistentCanvas()\n\n  function handleCanvasClick(e) {\n    const newLocation = { x: e.clientX, y: e.clientY }\n    setLocations([...locations, newLocation])\n  }\n\n  function handleClear() {\n    setLocations([])\n  }\n\n  function handleUndo() {\n    setLocations(locations.slice(0, -1))\n  }\n\n  function handleExport() {\n    const canvas = canvasRef.current\n\n    download(canvas.toDataURL())\n  }\n\n  console.log(localStorage);\n\n  return (\n    <>\n      <div className=\"controls\">\n        <button onClick={handleClear}>Clear</button>\n        <button onClick={handleUndo}>Undo</button>\n        <button onClick={handleExport}>Export PNG</button>\n      </div>\n      <canvas\n        ref={canvasRef}\n        width={window.innerWidth}\n        height={window.innerHeight}\n        onClick={handleCanvasClick}\n      />\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}