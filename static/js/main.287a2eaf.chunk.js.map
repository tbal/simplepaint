{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["usePersistentState","key","defaultValue","React","useState","JSON","parse","localStorage","getItem","value","setValue","useEffect","setItem","stringify","clearCanvas","ctx","clearRect","window","innerWidth","innerHeight","getColorAtPosition","x","y","r","g","b","imageData","getImageData","data","toString","length","drawImage","img","dx","dy","width","height","drawImageSrc","src","Image","Promise","resolve","onload","sequence","isPositioningUploadedImage","keepUploadedImage","App","isLoading","setIsLoading","isDrawing","setIsDrawing","isMouseMoved","setIsMouseMoved","isImageDragged","setIsImageDragged","history","setHistory","redoStack","setRedoStack","setCtx","uploadedImage","setUploadedImage","imageDimension","setImageDimension","start","setStart","end","setEnd","cursorPosition","setCursorPosition","colorAtColorPickerPosition","setColorAtColorPickerPosition","tool","setTool","previousTool","color","setColor","brushSize","setBrushSize","eraserSize","setEraserSize","canvasRef","useRef","dropZoneRef","uploadButtonRef","handleKeyUpDown","e","preventDefault","stopPropagation","type","handleDropZoneDrag","dataTransfer","dropEffect","addImage","file","match","reader","FileReader","readAsDataURL","dataset","base64","result","URL","createObjectURL","imageWidth","Math","min","redrawHistory","offset","historySize","changedHistory","changedRedoStack","slice","reverse","historyRedrawStartPosition","i","find","historyStep","found","a","redrawSingleHistoryStep","forEach","draw","lineWidth","forceTool","forceColor","forceLineWidth","save","lineJoin","lineCap","strokeStyle","globalCompositeOperation","beginPath","moveTo","fillStyle","rect","random","fill","lineTo","stroke","closePath","restore","stopDrawing","clientX","clientY","push","drawPoint","canvas","current","getContext","document","addEventListener","files","className","classList","add","body","remove","title","onChange","target","onClick","max","step","orient","class","click","ref","id","hidden","disabled","fileSource","fileName","link","createElement","setAttribute","style","display","appendChild","removeChild","download","toDataURL","onMouseDown","button","onMouseMove","onMouseUp","includes","onMouseOut","left","top","backgroundColor","alt","onWheel","deltaY","Boolean","location","hostname","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.287a2eaf.chunk.js","sourcesContent":["import React from 'react';\n\nimport './App.css';\n\n/**\n * Settings\n */\n// use transparent background for canvas\nconst TRANSPARENT_BACKGROUND = true;\n// color to use for canvas background, applies only if TRANSPARENT_BACKGROUND=false\nconst BACKGROUND_COLOR = '#ffffff'; // white\n// preselected brush tool; available values: pencil, spray, eraser, colorpicker\nconst DEFAULT_BRUSH = 'pencil';\n// preselected color for brush tools\nconst DEFAULT_BRUSH_COLOR = '#000000'; // black\n// preselected brush strength\nconst DEFAULT_BRUSH_SIZE = 20;\n// preselected brush strength\nconst DEFAULT_ERASER_SIZE = 50;\n// key to press to activate \"stamp-mode\" when placing added images\nconst KEY_STAMP_MODE = 'Alt';\n\n\n/**\n * Helper to convert rgb to hex color\n * \n * @param {number|string} r Red\n * @param {number|string} g Green\n * @param {number|string} b Blue\n * @returns {string} Hex color code \n */\nfunction rgbToHex(r, g, b) {\n  r = r.toString(16);\n  g = g.toString(16);\n  b = b.toString(16);\n\n  if (r.length === 1) {\n    r = '0' + r;\n  }\n  if (g.length === 1) {\n    g = '0' + g;\n  }\n  if (b.length === 1) {\n    b = '0' + b;\n  }\n\n  return '#' + r + g + b;\n}\n\n/**\n * Download given source file\n *\n * @param {string} fileSource\n * @param {string} fileName\n */\nfunction download(fileSource, fileName = 'image.png') {\n  const link = document.createElement('a');\n\n  link.setAttribute('href', fileSource);\n  link.setAttribute('download', fileName);\n\n  link.style.display = 'none';\n\n  document.body.appendChild(link);\n  link.click();\n  document.body.removeChild(link);\n}\n\n/**\n * Custom state hook using localStorage as data store\n *\n * @param {string} key Unique(!) key\n * @param {*} defaultValue Default value, if no value set already\n * @returns {*[]}\n */\nfunction usePersistentState(key, defaultValue) {\n  const [value, setValue] = React.useState(\n      JSON.parse(localStorage.getItem(key)) || defaultValue\n  );\n\n  React.useEffect(() => {\n    localStorage.setItem(key, JSON.stringify(value))\n  }, [key, value]);\n\n  return [value, setValue];\n}\n\n/**\n * Clears canvas and adds colored background if configured\n *\n * @param {CanvasRenderingContext2D} ctx\n */\nfunction clearCanvas(ctx) {\n  // clear everything on canvas\n  ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n  // fill canvas with white color if configured\n  if (!TRANSPARENT_BACKGROUND) {\n    ctx.fillStyle = BACKGROUND_COLOR;\n    ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);\n  }\n}\n\nfunction getColorAtPosition(ctx, x, y) {\n  const imageData = ctx.getImageData(x, y, 1, 1).data;\n\n  return rgbToHex(imageData[0], imageData[1], imageData[2]);\n}\n\nfunction drawImage(ctx, img, dx, dy, width, height) {\n  ctx.drawImage(img, dx, dy, width, height);\n}\n\nfunction drawImageSrc(ctx, src, dx, dy, width, height) {\n  const img = new Image();\n  img.src = src;\n  return new Promise(resolve => {\n    img.onload = () => {\n      drawImage(ctx, img, dx, dy, width, height);\n      resolve();\n    }\n  });\n}\n\n/**\n * Global state variables for which react states were too unreliable\n * @type {*[]}\n */\n// holds the sequence during one \"painting-move\", saved in history for undo/redo\nlet sequence = [];\n// the state when image was uploaded and user is able to move it around and add it on the canvas\nlet isPositioningUploadedImage = false;\n// a.k.a stamp-mode: keep uploaded image for adding it multiple times on canvas\nlet keepUploadedImage = false;\n\n/**\n * Main application\n */\nfunction App() {\n  /**\n   * States\n   */\n  const [isDebug, setIsDebug] = React.useState(false);\n  const [isLoading, setIsLoading] = React.useState(false);\n  const [isDrawing, setIsDrawing] = React.useState(false);\n  const [isMouseMoved, setIsMouseMoved] = React.useState(false);\n  const [isImageDragged, setIsImageDragged] = React.useState(false);\n\n  const [history, setHistory] = usePersistentState('history', []);\n  const [redoStack, setRedoStack] = usePersistentState('redoStack', []);\n\n  const [ctx, setCtx] = React.useState();\n  const [uploadedImage, setUploadedImage] = React.useState(null);\n  const [imageDimension, setImageDimension] = React.useState({width: 300, height: 300});\n\n  const [start, setStart] = React.useState({ x: 0, y: 0});\n  const [end, setEnd] = React.useState({ x: 0, y: 0});\n\n  const [cursorPosition, setCursorPosition] = React.useState({x: 0, y: 0});\n  const [colorAtColorPickerPosition, setColorAtColorPickerPosition] = React.useState(DEFAULT_BRUSH_COLOR);\n\n  const [tool, setTool] = usePersistentState('tool', DEFAULT_BRUSH);\n  const [previousTool, setPreviousTool] = usePersistentState('previousTool', DEFAULT_BRUSH);\n\n  const [color, setColor] = usePersistentState('color', DEFAULT_BRUSH_COLOR);\n  const [brushSize, setBrushSize] = usePersistentState('brushSize', DEFAULT_BRUSH_SIZE);\n  const [eraserSize, setEraserSize] = usePersistentState('eraserSize', DEFAULT_ERASER_SIZE);\n\n  /**\n   * References\n   */\n  const canvasRef = React.useRef(null);\n  const dropZoneRef = React.useRef(null);\n  const uploadButtonRef = React.useRef(null);\n\n  /**\n   * Somehow main hook initializing stuff only available after first render.\n   * Can be compared with document.onReady().\n   */\n  React.useEffect(() => {\n    // get canvas context and save in state\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    setCtx(ctx);\n\n    // resize canvas to full browser window size\n    canvas.width = window.innerWidth;\n    canvas.height = window.innerHeight;\n\n    addEventListeners();\n\n    // redraw saved drawing\n    redrawHistory(ctx);\n  }, [canvasRef]);\n\n  /**\n   * Set cursor-class depending on selected tool\n   */\n  React.useEffect(() => {\n    canvasRef.current.className = '';\n    canvasRef.current.classList.add('cursor-' + tool);\n  }, [tool])\n\n  /**\n   * Set loading-class depending on isLoading state\n   */\n  React.useEffect(() => {\n    if (isLoading) {\n      document.body.classList.add('loading');\n    } else {\n      document.body.classList.remove('loading');\n    }\n  }, [isLoading]);\n\n  /**\n   * Set when image was uploaded\n   * and user is able to move it around and add it on the canvas\n   */\n  React.useEffect(() => {\n    isPositioningUploadedImage = uploadedImage !== null;\n  }, [uploadedImage]);\n\n  function addEventListeners() {\n    // track cursor position in state\n    document.addEventListener('mousemove', (e) => {\n      setCursorPosition({ x: e.clientX, y: e.clientY });\n    });\n\n    // watch window resizing\n    window.addEventListener('resize', () => {\n      // resize canvas accordingly\n      canvasRef.current.width = window.innerWidth;\n      canvasRef.current.height = window.innerHeight;\n\n      // redraw everything as canvas gets cleared as soon as its\n      // width or height changes, see: https://stackoverflow.com/a/5517885\n      redrawHistory(canvasRef.current.getContext('2d'));\n    });\n\n    // watch key inputs\n    document.addEventListener('keydown', handleKeyUpDown);\n    document.addEventListener('keyup', handleKeyUpDown);\n\n\n    /**\n     * Drag & drop images onto canvas\n     */\n    window.addEventListener('dragover', (e) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      if (uploadedImage !== null) {\n        return;\n      }\n\n      setIsImageDragged(true);\n    });\n\n    dropZoneRef.current.addEventListener('dragenter', handleDropZoneDrag);\n    dropZoneRef.current.addEventListener('dragover', handleDropZoneDrag);\n\n    dropZoneRef.current.addEventListener('dragleave', () => {\n      setIsImageDragged(false);\n    });\n\n    dropZoneRef.current.addEventListener('drop', (e) => {\n      e.preventDefault();\n\n      if (uploadedImage !== null) {\n        return;\n      }\n\n      setIsImageDragged(false);\n\n      addImage(e.dataTransfer.files[0]);\n    });\n  }\n\n  function handleKeyUpDown(e) {\n    if (!isPositioningUploadedImage) {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    switch (e.key) {\n      case 'Escape':\n        if (e.type === 'keydown') {\n          setUploadedImage(null);\n          isPositioningUploadedImage = false;\n        }\n        break;\n      case KEY_STAMP_MODE:\n        keepUploadedImage = e.type === 'keydown';\n        break;\n      default:\n        // nothing\n    }\n  }\n\n  function handleDropZoneDrag(e) {\n    e.dataTransfer.dropEffect = 'copy';\n    e.preventDefault();\n  }\n\n  function addImage(file) {\n    // stop processing if file is not an image\n    if (!file.type.match(/image.*/)) {\n      return;\n    }\n\n    const img = new Image();\n    const reader = new FileReader();\n\n    // give visual feedback that image is loading\n    setIsLoading(true);\n\n    // use FileReader to get base64 file representation\n    reader.readAsDataURL(file);\n    reader.onload = () => {\n      // save base64 representation for using it in history later\n      img.dataset.base64 = reader.result;\n\n      // use object url to display the image\n      img.src = URL.createObjectURL(file);\n\n      // wait till image is loaded\n      img.onload = () => {\n        // save image in state\n        setUploadedImage(img);\n\n        // scale image to appropriate width, but prevent up-scaling\n        const imageWidth = Math.min(imageDimension.width, img.width);\n        setImageDimension({\n          width: imageWidth,\n          height: imageWidth * img.height / img.width\n        });\n\n        // finished loading (in theory..)\n        setIsLoading(false);\n      };\n    };\n  }\n\n  /**\n   * Redraws the canvas based on the saved history.\n   *\n   * If offset is set, it will undo (negative number) or rather redo (positive\n   * number) the history by the given number.\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} offset Negative offset results in undo, positive in redo.\n   */\n  function redrawHistory(ctx, offset= 0) {\n    // clear canvas at first\n    clearCanvas(ctx);\n\n    // history.length does not get updated here fast enough,\n    // because setHistory is async; that's why we introduce local helpers vars.\n    let historySize = history.length;\n    let changedHistory = null;\n\n    // Redo part - go forward in history by <offset> steps\n    if (offset > 0 && redoStack.length) {\n      changedHistory = [...history, redoStack[redoStack.length - 1]];\n      setHistory(changedHistory);\n      historySize++;\n      \n      const changedRedoStack = redoStack.slice(0, -1);\n      setRedoStack(changedRedoStack);\n    }\n\n    // Undo part - go back in history by <offset> steps\n    if (offset < 0 && history.length) {\n      // put last <offset> steps from history to redoStack\n      const changedRedoStack = [...redoStack, ...(history.slice(offset)).reverse()];\n      setRedoStack(changedRedoStack);\n      \n      changedHistory = history.slice(0, offset);\n      setHistory(changedHistory);\n      historySize += offset;\n    }\n\n    // History is empty, nothing to draw, canvas stays clear\n    if (!historySize) {\n      setIsLoading(false);\n      return;\n    }\n\n    // Optimization: Only redraw everything beginning after the last clear-step.\n    // This avoids flickering, especially when having images in the history.\n    let historyRedrawStartPosition = 0;\n    let i = 0;\n    [...history].reverse().find(historyStep => {\n      const found = historyStep.tool === 'clear';\n      if (found && i > 0) {\n        historyRedrawStartPosition = history.length - i;\n      }\n      i++;\n      return found;\n    });\n\n    // (Re-)Drawing images is an async job, that's why we must make sure\n    // the history processing stays chronological.\n    // Fancy async/await/anonymous function loop code found here:\n    // https://stackoverflow.com/a/40329190\n    (async function loop() {\n      for (let i = historyRedrawStartPosition; i < historySize; i++) {\n        await redrawSingleHistoryStep(ctx, (changedHistory || history)[i]);\n      }\n      setIsLoading(false);\n    })();\n  }\n\n  /**\n   * Redraw single history step\n   *\n   * @param ctx\n   * @param historyStep\n   * @returns {Promise<void>}\n   */\n  async function redrawSingleHistoryStep(ctx, historyStep) {\n    // Clear canvas\n    if (historyStep.tool === 'clear') {\n      clearCanvas(ctx);\n\n    // Draw image (async)\n    } else if (historyStep.tool === 'image') {\n      await drawImageSrc(ctx, historyStep.src, historyStep.dx, historyStep.dy, historyStep.width, historyStep.height);\n\n    // Draw sequences for defined tool (pencil, spray, eraser, etc.)\n    } else if (historyStep.sequence.length) {\n      historyStep.sequence.forEach(\n          sequence => draw(sequence[0], sequence[1], ctx,\n              historyStep.tool, historyStep.color,\n              historyStep.lineWidth));\n    }\n  }\n\n  /**\n   * Draw on canvas based on selected tool\n   */\n  function draw(start, end, ctx, forceTool, forceColor, forceLineWidth) {\n    ctx.save();\n\n    // draw rounded lines/points\n    ctx.lineJoin = 'round';\n    ctx.lineCap = 'round';\n\n    ctx.lineWidth =  forceLineWidth || brushSize;\n    ctx.strokeStyle = forceColor || color;\n\n    // Tool = Eraser\n    if (forceTool === 'eraser' || (typeof forceTool === 'undefined' && tool === 'eraser')) {\n      ctx.lineWidth = eraserSize;\n\n      if (TRANSPARENT_BACKGROUND) {\n        ctx.globalCompositeOperation = 'destination-out';\n      } else {\n        ctx.strokeStyle = BACKGROUND_COLOR;\n      }\n    }\n\n    ctx.beginPath();\n    ctx.moveTo(start.x, start.y);\n\n    // Tool = Spray\n    if (forceTool === 'spray' || (typeof forceTool === 'undefined' && tool === 'spray')) {\n      const lineWidth = forceLineWidth || brushSize;\n\n      ctx.fillStyle = forceColor || color;\n\n      ctx.rect(end.x, end.y, 1, 1);\n\n      for (let i = lineWidth; i--;) {\n        ctx.rect(\n            end.x + Math.random() * lineWidth - (lineWidth / 2),\n            end.y + Math.random() * lineWidth - (lineWidth / 2),\n            1, 1\n        );\n        ctx.fill();\n      }\n\n    // Tool = Pencil/Eraser\n    } else {\n      ctx.lineTo(end.x, end.y);\n      ctx.stroke();\n    }\n\n    ctx.closePath();\n    ctx.restore();\n  }\n\n  function stopDrawing(e) {\n    if (isDrawing === true && isMouseMoved === false) {\n      setStart({ x: e.clientX, y: e.clientY });\n      setEnd({ x: e.clientX, y: e.clientY });\n\n      drawPoint(start, end, ctx);\n    }\n\n    if (sequence.length) {\n      setHistory([...history, {\n        tool: tool,\n        lineWidth: tool === 'eraser' ? eraserSize : brushSize,\n        color: color,\n        sequence: sequence\n      }]);\n\n      // remove redo stack content\n      setRedoStack([]);\n\n      // reset sequence\n      sequence = [];\n    }\n\n    setIsDrawing(false);\n    setIsMouseMoved(false);\n  }\n\n  /**\n   * Fake drawing a single point\n   *\n   * @param start\n   * @param end\n   * @param ctx\n   */\n  function drawPoint(start, end, ctx) {\n    setEnd({x: end.x, y: ++end.y });\n\n    sequence.push([start, end]);\n\n    draw(start, end, ctx);\n  }\n\n  function handleCanvasMouseDown(e) {\n    // only main mouse button (usually left mouse button)\n    if (e.button !== 0 || tool === 'colorpicker') {\n      return;\n    }\n\n    setIsDrawing(true);\n\n    setStart({ x: e.clientX, y: e.clientY });\n    setEnd({ x: e.clientX, y: e.clientY });\n  }\n\n  function handleCanvasMouseMove(e) {\n    if (tool === 'colorpicker') {\n      setColorAtColorPickerPosition(getColorAtPosition(ctx, e.clientX, e.clientY));\n    }\n\n    if (isDrawing !== true) {\n      return;\n    }\n\n    setIsMouseMoved(true);\n\n    // draw line\n    setStart({ x: end.x, y: end.y });\n    setEnd({ x: e.clientX, y: e.clientY });\n\n    sequence.push([start, end]);\n\n    draw(start, end, ctx);\n  }\n\n  function handleCanvasMouseUp(e) {\n    if (tool === 'colorpicker') {\n      setColor(getColorAtPosition(ctx, e.clientX, e.clientY));\n      setTool(['pencil', 'spray'].includes(previousTool) ? previousTool : 'pencil');\n\n      return;\n    }\n\n    stopDrawing(e);\n  }\n\n  function handleCanvasMouseOut(e) {\n    stopDrawing(e);\n  }\n\n  function handleClear() {\n    clearCanvas(ctx);\n\n    // add clear-step to history\n    setHistory([...history, {\n      tool: 'clear'\n    }]);\n\n    // remove redo stack content\n    setRedoStack([]);\n  }\n\n  function handleUndo() {\n    setIsLoading(true);\n    redrawHistory(ctx, -1);\n  }\n\n  function handleRedo() {\n    setIsLoading(true);\n    redrawHistory(ctx, +1);\n  }\n\n  function handleExport() {\n    download(canvasRef.current.toDataURL());\n  }\n\n  function handleFileUploadProxy() {\n    uploadButtonRef.current.click();\n  }\n\n  /**\n   * Handle file uploaded by button\n   */\n  function handleFileUpload(e) {\n    addImage(e.target.files[0]);\n  }\n\n  function handleNew() {\n    // clear canvas completely\n    clearCanvas(ctx);\n\n    // remove history content\n    setHistory([]);\n\n    // remove redo stack content\n    setRedoStack([]);\n  }\n\n  function handleSelectToolColorPicker(e) {\n    // save previously used tool to allow switching back after color was picked\n    setPreviousTool(tool);\n\n    // switch to colorpicker tool\n    setTool(e.target.value);\n  }\n\n  function handleUploadedImageClick() {\n    if (uploadedImage !== null) {\n      drawImage(\n          ctx,\n          uploadedImage,\n          cursorPosition.x - (imageDimension.width / 2),\n          cursorPosition.y - (imageDimension.height / 2),\n          imageDimension.width,\n          imageDimension.height\n      );\n\n      setHistory([...history, {\n        tool: 'image',\n        src: uploadedImage.dataset.base64,\n        dx: cursorPosition.x - (imageDimension.width / 2),\n        dy: cursorPosition.y - (imageDimension.height / 2),\n        width: imageDimension.width,\n        height: imageDimension.height\n      }]);\n      setRedoStack([]);\n\n      if (!keepUploadedImage) {\n        setUploadedImage(null);\n      }\n    }\n  }\n\n  function handleUploadedImageZoom(e) {\n    const deltaY = e.deltaY * -0.5;\n\n    let imageWidth = imageDimension.width + deltaY;\n\n    // restrict min width of image\n    imageWidth = Math.max(50, imageWidth);\n\n    setImageDimension({\n      width: imageWidth,\n      height: imageWidth * e.target.height / e.target.width\n    });\n  }\n\n  return (\n    <>\n      <div className=\"icon-bar\">\n        <span>\n          <input title=\"Farbauswahl\" type=\"color\" value={color}\n                 onChange={e => { setColor(e.target.value); tool === 'eraser' && setTool('pencil'); }} />\n        </span>\n\n        <div className=\"spacer\"/>\n\n        <div className=\"section\">\n          <button title=\"Pinsel\"\n                  onClick={() => setTool('pencil')}\n                  className={(tool === 'pencil' ? 'active ' : '') + 'has-option-bar'}>\n            <i className=\"fas fa-pencil-alt\"/>\n          </button>\n\n          <div className=\"option-bar\">\n            <span><i className=\"fas fa-circle\"/></span>\n            <input title=\"Pinselstärke\" type=\"range\" value={brushSize}\n                   onChange={e => { setBrushSize(e.target.value); setTool('pencil'); }}\n                   min=\"1\" max=\"100\" step=\"1\" orient=\"vertical\" />\n            <span><i className=\"fas fa-circle\"/></span>\n          </div>\n        </div>\n\n        <div className=\"section\">\n          <button title=\"Sprühflasche\"\n                  onClick={() => setTool('spray')}\n                  className={(tool === 'spray' ? 'active ' : '') + 'has-option-bar'}>\n            <i className=\"fas fa-spray-can\"/>\n          </button>\n\n          <div className=\"option-bar\">\n            <span class=\"circle-crop\"><i className=\"fas fa-chess-board\"/></span>\n            <input title=\"Sprühstärke\" type=\"range\" value={brushSize}\n                   onChange={e => { setBrushSize(e.target.value); setTool('spray'); }}\n                   min=\"1\" max=\"100\" step=\"1\" orient=\"vertical\" />\n            <span class=\"circle-crop\"><i className=\"fas fa-chess-board\"/></span>\n          </div>\n        </div>\n\n        <div className=\"section\">\n          <button title=\"Radierer\"\n                  onClick={() => setTool('eraser')}\n                  className={(tool === 'eraser' ? 'active ' : '') + 'has-option-bar'}>\n            <i className=\"fas fa-eraser\"/>\n          </button>\n\n          <div className=\"option-bar\">\n            <span><i className=\"far fa-circle\"/></span>\n            <input title=\"Radierergröße\" type=\"range\" value={eraserSize}\n                   onChange={e => { setEraserSize(e.target.value); setTool('eraser'); }}\n                   min=\"1\" max=\"100\" step=\"1\" orient=\"vertical\" />\n            <span><i className=\"far fa-circle\"/></span>\n          </div>\n        </div>\n\n        <button title=\"Farbpipette\"\n                onClick={() => setTool('colorpicker')}\n                className={tool === 'colorpicker' ? 'active ' : ''}>\n          <i className=\"fas fa-eye-dropper\"/>\n        </button>\n\n        <div className=\"spacer\"/>\n\n        <button onClick={handleFileUploadProxy} title=\"Bild einfügen\">\n          <i className=\"fas fa-image\"/>\n        </button>\n        <input ref={uploadButtonRef} id=\"uploadButton\" type=\"file\" onChange={handleFileUpload} hidden />\n\n        <div className=\"spacer\"/>\n\n        <button title=\"Rückgängig machen\" onClick={handleUndo}\n                disabled={!history.length}>\n          <i className=\"fas fa-undo\"/>\n        </button>\n        <button title=\"Wiederholen\" onClick={handleRedo}\n                disabled={!redoStack.length}>\n          <i className=\"fas fa-redo\"/>\n        </button>\n        <button title=\"Zeichnung leeren\" onClick={handleClear}\n                disabled={!history.length || history[history.length - 1].tool === 'clear'}>\n          <i className=\"fas fa-broom\"/>\n        </button>\n\n        <div className=\"spacer\"/>\n\n        <button title=\"Zeichnung als PNG exportieren\" onClick={handleExport}>\n          <i className=\"fas fa-file-download\"/>\n        </button>\n\n        <div className=\"spacer\"/>\n\n        <button title=\"Zeichnung verwerfen\" onClick={handleNew}\n                disabled={!history.length && !redoStack.length}>\n          <i className=\"fas fa-trash-alt\"/>\n        </button>\n      </div>\n\n      <canvas\n        ref={canvasRef}\n        onMouseDown={handleCanvasMouseDown}\n        onMouseMove={handleCanvasMouseMove}\n        onMouseUp={handleCanvasMouseUp}\n        onMouseOut={handleCanvasMouseOut}\n      />\n\n      <div id=\"colorPickerTooltip\"\n           style={{ left: cursorPosition.x, top: cursorPosition.y + 20, backgroundColor: colorAtColorPickerPosition }}\n           className={tool === 'colorpicker' ? '' : 'hidden '} />\n\n      <div ref={dropZoneRef} id=\"dropZone\" className={isImageDragged ? '' : 'hidden '} />\n\n      <img id=\"uploadedImage\" src={uploadedImage !== null ? uploadedImage.src : ''} alt=\"\"\n           className={uploadedImage === null ? 'hidden' : ''}\n           style={{\n             left: uploadedImage === null ? 0 : (cursorPosition.x - (imageDimension.width / 2)),\n             top: uploadedImage === null ? 0 : (cursorPosition.y - (imageDimension.height / 2))\n           }}\n           width={imageDimension.width}\n           height={imageDimension.height}\n           onClick={handleUploadedImageClick}\n           onWheel={handleUploadedImageZoom}\n      />\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}